- [Preface](#sec-)
- [Lagrangian Mechanics](#sec-1)
  - [Configuration Spaces](#sec-1-1)
  - [Generalized Coordinates](#sec-1-2)
  - [The Principle of Stationary Action](#sec-1-3)
  - [Computing Actions](#sec-1-4)
  - [The Euler–Lagrange Equations](#sec-1-5)
    - [Derivation of the Lagrange Equations](#sec-1-5-1)
    - [Computing Lagrange's Equations](#sec-1-5-2)
  - [How to Find Lagrangians](#sec-1-6)
    - [Coordinate Transformations](#sec-1-6-1)
    - [Systems with Rigid Constraints](#sec-1-6-2)
    - [Constraints as Coordinate Transformations](#sec-1-6-3)
    - [The Lagrangian Is Not Unique](#sec-1-6-4)
  - [Evolution of Dynamical State](#sec-1-7)
  - [Conserved Quantities](#sec-1-8)
    - [Conserved Momenta](#sec-1-8-1)
    - [Energy Conservation](#sec-1-8-2)
    - [Central Forces in Three Dimensions](#sec-1-8-3)
    - [The Restricted Three-Body Problem](#sec-1-8-4)
    - [Noether's Theorem](#sec-1-8-5)
  - [Abstraction of Path Functions](#sec-1-9)
  - [Constrained Motion](#sec-1-10)
    - [Coordinate Constraints](#sec-1-10-1)
    - [Derivative Constraints](#sec-1-10-2)
    - [Nonholonomic Systems](#sec-1-10-3)
  - [Summary](#sec-1-11)
  - [Projects](#sec-1-12)
- [Rigid Bodies](#sec-2)
  - [Rotational Kinetic Energy](#sec-2-1)
  - [Kinematics of Rotation](#sec-2-2)
  - [Moments of Inertia](#sec-2-3)
  - [Inertia Tensor](#sec-2-4)
  - [Principal Moments of Inertia](#sec-2-5)
  - [Vector Angular Momentum](#sec-2-6)
  - [Euler Angles](#sec-2-7)
  - [Motion of a Free Rigid Body](#sec-2-8)
    - [Computing the Motion of Free Rigid Bodies](#sec-2-8-1)
    - [Qualitative Features](#sec-2-8-2)
  - [Euler's Equations](#sec-2-9)
  - [Axisymmetric Tops](#sec-2-10)
  - [Spin-Orbit Coupling](#sec-2-11)
    - [Development of the Potential Energy](#sec-2-11-1)
    - [Rotation of the Moon and Hyperion](#sec-2-11-2)
    - [Spin-Orbit Resonances](#sec-2-11-3)
  - [Nonsingular Coordinates and Quaternions](#sec-2-12)
    - [Motion in Terms of Quaternions](#sec-2-12-1)
  - [Summary](#sec-2-13)
  - [Projects](#sec-2-14)
- [Hamiltonian Mechanics](#sec-3)
  - [Hamilton's Equations](#sec-3-1)
    - [The Legendre Transformation](#sec-3-1-1)
    - [Hamilton's Equations from the Action Principle](#sec-3-1-2)
    - [A Wiring Diagram](#sec-3-1-3)
  - [Poisson Brackets](#sec-3-2)
  - [One Degree of Freedom](#sec-3-3)
  - [Phase Space Reduction](#sec-3-4)
    - [Lagrangian Reduction](#sec-3-4-1)
  - [Phase Space Evolution](#sec-3-5)
    - [Phase-Space Description Is Not Unique](#sec-3-5-1)
  - [Surfaces of Section](#sec-3-6)
    - [Periodically Driven Systems](#sec-3-6-1)
    - [Computing Stroboscopic Surfaces of Section](#sec-3-6-2)
    - [Autonomous Systems](#sec-3-6-3)
    - [Computing Hénon–Heiles Surfaces of Section](#sec-3-6-4)
    - [Non-Axisymmetric Top](#sec-3-6-5)
  - [Exponential Divergence](#sec-3-7)
  - [Liouville's Theorem](#sec-3-8)
  - [Standard Map](#sec-3-9)
  - [Summary](#sec-3-10)
  - [Projects](#sec-3-11)
- [Phase Space Structure](#sec-4)
  - [Emergence of the Divided Phase Space](#sec-4-1)
  - [Linear Stability](#sec-4-2)
    - [Equilibria of Differential Equations](#sec-4-2-1)
    - [Fixed Points of Maps](#sec-4-2-2)
    - [Relations Among Exponents](#sec-4-2-3)
  - [Homoclinic Tangle](#sec-4-3)
    - [Computation of Stable and Unstable Manifolds](#sec-4-3-1)
  - [Integrable Systems](#sec-4-4)
  - [Poincaré–Birkhoff Theorem](#sec-4-5)
    - [Computing the Poincaré–Birkhoff Construction](#sec-4-5-1)
  - [Invariant Curves](#sec-4-6)
    - [Finding Invariant Curves](#sec-4-6-1)
    - [Dissolution of Invariant Curves](#sec-4-6-2)
  - [Summary](#sec-4-7)
  - [Projects](#sec-4-8)
- [Canonical Transformations](#sec-5)
  - [Point Transformations](#sec-5-1)
  - [General Canonical Transformations](#sec-5-2)
    - [Time-Dependent Transformations](#sec-5-2-1)
    - [Abstracting the Canonical Condition](#sec-5-2-2)
  - [Invariants of Canonical Transformations](#sec-5-3)
  - [Generating Functions](#sec-5-4)
    - [F1 Generates Canonical Transformations](#sec-5-4-1)
    - [Generating Functions and Integral Invariants](#sec-5-4-2)
    - [Types of Generating Functions](#sec-5-4-3)
    - [Point Transformations](#sec-5-4-4)
    - [Total Time Derivatives](#sec-5-4-5)
  - [Extended Phase Space](#sec-5-5)
    - [Poincaré–Cartan Integral Invariant](#sec-5-5-1)
  - [Reduced Phase Space](#sec-5-6)
  - [Summary](#sec-5-7)
  - [Projects](#sec-5-8)
- [Canonical Evolution](#sec-6)
  - [Hamilton–Jacobi Equation](#sec-6-1)
    - [Harmonic Oscillator](#sec-6-1-1)
    - [Hamilton–Jacobi Solution of the Kepler Problem](#sec-6-1-2)
    - [F2 and the Lagrangian](#sec-6-1-3)
    - [The Action Generates Time Evolution](#sec-6-1-4)
  - [Time Evolution is Canonical](#sec-6-2)
    - [Another View of Time Evolution](#sec-6-2-1)
    - [Yet Another View of Time Evolution](#sec-6-2-2)
  - [Lie Transforms](#sec-6-3)
  - [Lie Series](#sec-6-4)
  - [Exponential Identities](#sec-6-5)
  - [Summary](#sec-6-6)
  - [Projects](#sec-6-7)
- [Canonical Perturbation Theory](#sec-7)
  - [Perturbation Theory with Lie Series](#sec-7-1)
  - [Pendulum as a Perturbed Rotor](#sec-7-2)
    - [Higher Order](#sec-7-2-1)
    - [Eliminating Secular Terms](#sec-7-2-2)
  - [Many Degrees of Freedom](#sec-7-3)
    - [Driven Pendulum as a Perturbed Rotor](#sec-7-3-1)
  - [Nonlinear Resonance](#sec-7-4)
    - [Pendulum Approximation](#sec-7-4-1)
    - [Reading the Hamiltonian](#sec-7-4-2)
    - [Resonance-Overlap Criterion](#sec-7-4-3)
    - [Higher-Order Perturbation Theory](#sec-7-4-4)
    - [Stability of the Inverted Vertical Equilibrium](#sec-7-4-5)
  - [Summary](#sec-7-5)
  - [Projects](#sec-7-6)
- [Scheme](#sec-8)
- [Our Notation](#sec-9)
  - [Summary](#sec-9-1)
  - [Exercises](#sec-9-2)
- [Org-Mode Demo](#sec-10)
    - [Equations](#sec-10-0-1)

Welcome to my tour of Structure and Interpretation of Classical Mechanics. I'm working on this book to develop my sense of the best way to do research in public; this book is heavy on math, programming and visualization, and should stress the normal tools.

I'm attempting to take notes in on org-mode file, and generate all my code from there.

I don't think I have the heart, or the time, to really do high-class notes of every single section; but I am going to do each of the exercises, and explore some of the code-based concepts in each section.

# Preface<a id="sec-"></a>

The preface is already intriguing. A tour through the new notation, plus some discussion of why a programming language is the best route in to this stuff. Both of these are extremely powerful ideas, and why I was pulled to this book in the first place.

The functional notation is:

\begin{equation}
  D (\partial\_2 L \circ \Gamma[q]) - (\partial\_1 L \circ \Gamma[q]) = 0
\end{equation}

Compare that to the traditional notation:

\begin{equation}
  \frac{d}{dt} \frac{\partial L}{\partial \dot q^i} -\frac{\partial L}{\partial q^i}= 0
\end{equation}

They have a nice riff on how this is totally ambiguous. \\(\Gamma\\) is not a great way to go.

# Lagrangian Mechanics<a id="sec-1"></a>

The book's about motion, how things move. Here's a nice image of some action getting minimized:

![img](https://github.com/sritchie/sicm/raw/master/images/Lagrangian_Mechanics/2020-05-29_10-12-19_AJBpDgU.gif)

## Configuration Spaces<a id="sec-1-1"></a>

1.  Exercises 1.1: Degrees of Freedom and 1.2: Generalized Coordinates

    > For each of the mechanical systems described below, give the number of degrees of freedom of the configuration space.

    (Exercise 1.2 asks about the generalized coordinates of each, so I'll note those here too.)

    1.  Three juggling pins.

        ****18 degrees of freedom**** for three juggling pins - 3 position, 3 angles for each. OR ****15**** total, if you assume that the pin is symmetric; then you just need two degrees of tilt.

    2.  A spherical pendulum consisting of a point mass (the pendulum bob) hanging from a rigid massless rod attached to a fixed support point. The pendulum bob may move in any direction subject to the constraint imposed by the rigid rod. The point mass is subject to the uniform force of gravity.

        Spherical pendulum,hanging from a fixed support has ****two degrees of freedom****, one for each angle.

    3.  Spherical DOUBLE pendulum has ****four degrees of freedom****; two angles from previous, plus two more angles for the second pendulum off of the first.

        A spherical double pendulum, consisting of one point mass hanging from a rigid massless rod attached to a second point mass hanging from a second massless rod attached to a fixed support point. The point masses are subject to the uniform force of gravity.

    4.  A point mass sliding without friction on a rigid curved wire.

        ****1 degree of freedom****, distance along the wire.

    5.  A top consisting of a rigid axisymmetric body with one point on the symmetry axis of the body attached to a fixed support, subject to a uniform gravitational force.

        Axisymmetric top has ****TWO degrees of freedom****, for the angles off of vertical. But then we can't talk about its speed, so that's a little strange. I guess it has an angular momentum as a property, but that's not a coordinate.

    6.  The same as e, but not axisymmetric.

        We now have ****THREE degrees of freedom****, one more for the angle of the top's rotation.

## Generalized Coordinates<a id="sec-1-2"></a>

## The Principle of Stationary Action<a id="sec-1-3"></a>

1.  Exercise 1.3: Fermat optics

    The problem states:

    > Fermat observed that the laws of reflection and refraction could be accounted for by the following facts: Light travels in a straight line in any particular medium with a velocity that depends upon the medium. The path taken by a ray from a source to a destination through any sequence of media is a path of least total time, compared to neighboring paths. Show that these facts imply the laws of reflection and refraction.

## Computing Actions<a id="sec-1-4"></a>

\\({1 \over 2} mv^2\\). This is the Lagrangian for a free particle, though I have no idea "why". Nor would I have thought about it had the text not said "we know you don't know why"&#x2026;

Now it's 2020, and I totally know why. The Lagrangian is defined this way because there's no potential, no other forces acting on the particle; so all it has is its kinetic energy.

WHY is the Lagrangian defined this way? Because, when we can split the functions into one that depends on velocity ("kinetic energy") and a potential that depends only on position, it just works out this way.

1.  Exercise 1.4: Lagrangian actions

2.  Exercise 1.5: Solution process

3.  Exercise 1.6: Minimizing action

    The problem asks:

    > Suppose we try to obtain a path by minimizing an action for an impossible problem. For example, suppose we have a free particle and we impose endpoint conditions on the velocities as well as the positions that are inconsistent with the particle being free. Does the formalism protect itself from such an unpleasant attack? You may find it illuminating to program it and see what happens.

    I spent some time thinking about this, because when I attacked this book five years ago this problem clearly tripped me up.

    Let's say you take, as they suggest, some path, and impose velocity constraints on the endpoints in addition to the position constraints.

    Usually, you constrain the coordinates at each endpoint and force a path that minimizes the action between two times. So what does it mean to impose velocity conditions? The key is to realize that on the computer, you're forcing a path to be composed of a bunch of discrete points. If you can force a point into the path that is NOT controlled by the optimizer, then you can force a velocity at some point in the path that makes no sense for minimal action.

    ```scheme
    (define (((parametric-path-action* win)
              Lagrangian t0 q0 offset0 t1 q1 offset1)
             intermediate-qs)
      (let ((intermediate-qs* (append (list (- q0 offset0))
                                      intermediate-qs
                                      (list (+ q1 offset1)))))
        (let ((path (make-path t0 q0 t1 q1 intermediate-qs*)))
          ;; display path
          (graphics-clear win)
          (plot-function win path t0 t1 (/ (- t1 t0) 100))
          ;; compute action
          (Lagrangian-action Lagrangian path t0 t1))))

    ;; Version of find path that allows for an offset to the initial and
    ;; final points.

    (define ((find-path* win) L t0 q0 offset0 t1 q1 offset1 n)
      (let ((initial-qs (linear-interpolants q0 q1 n)))
        (let* ((action (parametric-path-action* win))
               (minimizing-qs
                (multidimensional-minimize
                 (action L t0 q0 offset0 t1 q1 offset1)
                 initial-qs)))
          (make-path t0 q0 t1 q1 minimizing-qs))))

    ;; This runs (and graphs!) the motion of a free particle using the
    ;; fucked up path.
    (define (one-six offset0 offset1 n)
      (let* ((tmax 10)
             (win (frame -1 (+ tmax 1) 0. (+ 1.2 offset0 offset1)))
             (find (find-path* win))
             (L (L-free-particle 3.0))
             (path (find L
                         0. 1. offset0
                         tmax 0. offset1
                         n)))
        (Lagrangian-action L path 0 tmax)))
    ```

    What happens when you program this? You get a funky, wiggly path like this: (insert the gif!)

    And you can show that the action you calculate is NOT in fact the minimum. Here's an interface that says "take 3 interpolated points, and force an offset point of a small amount into the action.

    ```scheme
    (one-six 0 0 3)
    ```

    ```scheme
    (one-six 0.2 0 3)
    ```

    You <span class="underline"><span class="underline">still</span></span> can get the process to converge! But that is only because you're not minimizing action with respect to some Lagrangian anymore; you're minimizing the action of two constraints. You have the Lagrangian, and then the warring goal of the polynomial interpolation. At some point, the minimizer breaks as you almost certainly oscillate between two paths, as each constraint tugs at you.

    If you make the impulse too big, then the war is too hardcore and the process never converges. But it's important to note here the details of the optimizer. The only reason this can "work" is settings on the optimizer.

## The Euler–Lagrange Equations<a id="sec-1-5"></a>

### Derivation of the Lagrange Equations<a id="sec-1-5-1"></a>

1.  Exercise 1.7: Properties of \\(\delta\\)

2.  Exercise 1.8: Implementation of \\(\delta\\)

    This FEELS weird&#x2026; but we want something that is&#x2026; well, let's see.

    ```scheme
    (define (((delta eta) f) q)
      (let (g (lambda (eps)
                (f (q + (* eps eta)))))
        ((D g) 0)))
    ```

    Why does this work? WELL&#x2026; we need a way to force the limit in.

    this is a PATH function, remember. This takes a path function, then passes it into \\(\Gamma\\), and composes THAT with F. F is a function from the local tuple to some output variable. You can imagine it as the Langrangian, for example.

    The local tuple type defined here can take any number of path components.

    ```scheme
    (define (f q)
      (let* ((Local (Up Real (UP* Real) (UP* Real)))
             (F (literal-function 'F (-> Local Real))))
        (compose F (Gamma q))))
    ```

    This is a path function that returns a 2d path; we can use this as an example.

    ```scheme
    (define q (literal-function 'q (-> Real (Up Real Real))))
    ```

3.  Exercise 1.9: Lagrange's equations

4.  Exercise 1.10: Higher-derivative Lagrangians

### Computing Lagrange's Equations<a id="sec-1-5-2"></a>

1.  Exercise 1.11: Kepler's third law

2.  Exercise 1.12: Lagrange's equations (code)

3.  Exercise 1.13: Higher-derivative Lagrangians (code)

## How to Find Lagrangians<a id="sec-1-6"></a>

1.  Exercise 1.14: Coordinate-independence of Lagrange equations

### Coordinate Transformations<a id="sec-1-6-1"></a>

1.  Exercise 1.15: Equivalence

    This one was a serious doozy. I plan on going through and co

    Checking that composition distributes over multiplication&#x2026;

    ```scheme
    (define f (literal-function 'f))
    (define g (literal-function 'g))
    (define h (literal-function 'h))
    ```

    looks good! These are the same expression.

    ```scheme
    ((compose (* f g) h) 't)
    ((* (compose f h) (compose g h)) 't)
    ```

    This is the general form of a path transformation; big surprise, this is very close to the code on page 46. I'm going to keep my version, since I don't want to get too confused, here.

    ```scheme
    (define ((F->C F) local)
      (let ((t (time local))
            (x (coordinate local))
            (v (velocity local)))
        (up t
            (F t x)
            (+ (((partial 0) F) t x)
               (* (((partial 1) F) t x)
                  v)))))
    ```

    Here's a literal function we can play with.

    ```scheme
    (define F*
      (literal-function 'F (-> (X Real Real) Real)))
    ```

    Okay, boom, this is the literal function.

    ```scheme
    (define q-prime
      (literal-function 'q-prime))
    ```

    This is the manual generation of q from q-prime.

    ```scheme
    (define ((to-q F) qp)
      (lambda (t) (F t (qp t))))
    ```

    We can check that these are now equal. This uses C to get us to q

    ```scheme
    ((compose (F->C F*) (Gamma q-prime)) 't)
    ```

    And this does it by passing in q manually.

    ```scheme
    ((Gamma ((to-q F*) q-prime)) 't)
    ```

    I can convert the proof to code, no problem, by showing that these sides are equal.

    YES!! the final step of my proof was the note that these are equal. THIS IS HUGE!!!

    ```scheme
    ((compose (lambda (x) (ref x 1)) ((partial 1) (F->C F*)) (Gamma q-prime)) 't)
    ((compose (lambda (x) (ref x 2)) ((partial 2) (F->C F*)) (Gamma q-prime)) 't)
    ```

    Just for fun, note that this successfully pushes things inside gamma.

    ```scheme
    (let ((L (literal-function 'L (-> (UP Real Real Real) Real)))
          (C (F->C F*)))
      ((Gamma ((to-q ((partial 1) F*)) q-prime)) 't))

    (define (p->r t polar-tuple)
      (let* ((r (ref polar-tuple 0))
             (phi (ref polar-tuple 1))
             (x (* r (cos phi)))
             (y (* r (sin phi))))
        (up x y)))

    (literal-function 'q-prime (-> Real (UP Real Real)))((Gamma ((to-q p->r) )) 't)
    ```

    trying again. get a function:

    ```scheme
    (define q
      ;; time to x y.
      (literal-function 'q (-> Real (UP Real Real))))

    (define (C local)
      (up (time local)
         (square (coordinate local))
         (velocity local)))

    ((compose C (Gamma q)) 't)
    ```

    That's good for now.

2.  Exercise 1.16: Central force motion

    Messing around to make sure I understand what I'm seeing in the coordinate transforms on page 45.

    ```scheme
    (load "ch1/utils.scm")

    (define (p->r local)
      (let* ((polar-tuple (coordinate local))
             (r (ref polar-tuple 0))
             (phi (ref polar-tuple 1))
             (x (* r (cos phi)))
             (y (* r (sin phi))))
        (up x y)))

    (define (spherical->rect local)
      (let* ((spherical-tuple (coordinate local))
             (r (ref spherical-tuple 0))
             (theta (ref spherical-tuple 1))
             (phi (ref spherical-tuple 2)))
        (up (* r (sin theta) (cos phi))
            (* r (sin theta) (sin phi))
            (* r (cos theta)))))
    ```

    Check polar:

    ```scheme
    (show-expression
     ((F->C p->r)
      (up 't
          (up 'r 'phi)
          (up 'rdot 'phidot))))
    ```

    spherical coordinate change, check velocities:

    ```scheme
    (show-expression
     ((F->C spherical->rect)
      (up 't
          (up 'r 'theta 'phi)
          (up 'rdot 'thetadot 'phidot))))

    (show-expression
     (square (ref (ref ((F->C spherical->rect)
                 (up 't
                     (up 'r 'theta 'phi)
                     (up 'rdot 'thetadot 'phidot))) 2) 0)))
    ```

    get the Langrangian from page 41:

    ```scheme
    (define ((L-central-rectangular m U) local)
      (let ((q (coordinate local))
            (v (velocity local)))
        (- (* 1/2 m (square v))
           (U (sqrt (square q))))))
    ```

    BOOM, now we can compose these things!

    ```scheme
    (define (L-central-polar m U)
      (compose (L-central-rectangular m U)
               (F->C p->r)))

    (define (L-central-spherical m U)
      (compose (L-central-rectangular m U)
               (F->C spherical->rect)))
    ```

    Confirm the polar coordinate version&#x2026;

    ```scheme
    (show-expression
     ((L-central-polar 'm (literal-function 'U))
      (up 't
          (up 'r 'phi)
          (up 'rdot 'phidot))))
    ```

    BOOM, much better than calculating by hand!

    ```scheme
    (show-expression
     ((L-central-spherical 'm (literal-function 'U))
      (up 't
          (up 'r 'theta 'phi)
          (up 'rdot 'thetadot 'phidot))))
    ```

    rectangular, for fun:

    ```scheme
    (show-expression
     ((L-central-rectangular 'm (literal-function 'U))
      (up 't
          (up 'x 'y 'z)
          (up 'xdot 'ydot 'zdot))))
    ```

    From a note to Vinay. Langrangian coordinate transformation from spherical -> rectangular on paper, which of course is a total nightmare, writing vx<sup>2</sup> + vy<sup>2</sup> + vz<sup>2</sup> and simplifying. BUT then, of course, you write down the spherical => rectangular position change&#x2026;

    the explicit link to function composition, and how the new lagrangian is (Lagrangian A + A<-B + B<-C)&#x2026; really drives home how invertible coordinate transforms can stack associatively through function composition. the lesson is, prove that the code works, then trust the program to go to crazy coordinate systems.

    they add in a very simple-to-write coordinate transform that has one of the angles depend on t. and then compose that in, and boom, basically for free you're in rotating spherical coords.

### Systems with Rigid Constraints<a id="sec-1-6-2"></a>

1.  Exercise 1.17: Bead on a helical wire

2.  Exercise 1.18: Bead on a triaxial surface

3.  Exercise 1.19: Two-bar linkage

4.  Exercise 1.20: Sliding pendulum

5.  Exercise 1.21: A dumbbell

    The uneven dumbbell.

    ```scheme
    (load "ch1/utils.scm")
    ```

    Takes in any number of up tuples and zips them into a new list of up-tuples by taking each element.

    ```scheme
    (define (up-zip . ups)
      (apply vector-map up (map up->vector ups)))
    ```

    I spent some time trying to make a nice API&#x2026; but without map, filter, reduce etc on tuples it is quite annoying. So let's go ad hoc first and see what happens.

    ```scheme
    (define (KE-particle m v)
      (* 1/2 m (square v)))
    ```

    ```scheme
    ;; gets the particle itself
    (define ((extract-particle pieces) local i)
      (let* ((q (coordinate local))
             (qdot (velocity local))
             (indices (apply up (iota pieces (* i pieces))))
             (extract (lambda (tuple)
                        (vector-map (lambda (i) (ref tuple i))
                                    indices))))
        (up (time q)
            (extract q)
            (extract qdot))))

    (define (constraint q0 q1 F l)
      (* (/ F (* 2 l))
         (- (square (- q1 q0))
            (square l))))

    (define ((L-free-constrained m0 m1 l) local)
      (let* ((extract (extract-particle 2))
             (p0 (extract local 0))
             (q_0 (coordinate p0))
             (qdot_0 (velocity p0))

             (p1 (extract local 1))
             (q_1 (coordinate p1))
             (qdot_1 (velocity p1))

             (F (ref (coordinate local) 4)))
        (- (+ (KE-particle m0 qdot_0)
              (KE-particle m1 qdot_1))
           (constraint q_0 q_1 F l))))

    (define q-rect
      (up (literal-function 'x_0)
          (literal-function 'y_0)
          (literal-function 'x_1)
          (literal-function 'y_1)
          (literal-function 'F)))
    ```

    This shows the lagrangian itself, which answers part b:

    ```scheme
    (let* ((L (L-free-constrained 'm_0 'm_1 'l))
           (f (compose L (Gamma q-rect))))
      (se (f 't)))
    ```

    Here are the lagrange equations, confirming part b.

    ```scheme
    (let* ((L (L-free-constrained 'm_0 'm_1 'l))
           (f ((Lagrange-equations L) q-rect)))
      (se (f 't)))
    ```

    Part c - make a change of coordinates.

    ```scheme
    (define ((cm-theta->rect m0 m1) local)
      (let* ((q (coordinate local))
             (x_cm (ref q 0))
             (y_cm (ref q 1))
             (theta (ref q 2))
             (c (ref q 3))
             (F (ref q 4))
             (total-mass (+ m0 m1))
             (m0-distance (* c (/ m1 total-mass)))
             (m1-distance (* c (/ m0 total-mass))))
        (up (- x_cm (* m0-distance (cos theta)))
            (- y_cm (* m0-distance (sin theta)))
            (+ x_cm (* m1-distance (cos theta)))
            (+ y_cm (* m1-distance (sin theta)))
            F)))

    (se
     ((F->C (cm-theta->rect 'm_0 'm_1))
      (up 't
          (up 'x_cm 'y_cm 'theta 'c 'F)
          (up 'xdot_cm 'ydot_cm 'thetadot 'cdot 'Fdot))))

    (define (L-free-constrained-new m0 m1 l)
      (compose (L-free-constrained m0 m1 l)
               (F->C (cm-theta->rect m0 m1))))
    ```

    This shows the lagrangian itself, after the coordinate transformation:

    ```scheme
    (let* ((q (up (literal-function 'x_cm)
                  (literal-function 'y_cm)
                  (literal-function 'theta)
                  (literal-function 'c)
                  (literal-function 'F)))
           (L (L-free-constrained-new 'm_0 'm_1 'l))
           (f (compose L (Gamma q))))
      (se (f 't)))
    ```

    Here are the lagrange equations for part c.

    ```scheme
    (let* ((q (up (literal-function 'x_cm)
                  (literal-function 'y_cm)
                  (literal-function 'theta)
                  (literal-function 'c)
                  (literal-function 'F)))
           (L (L-free-constrained-new 'm_0 'm_1 'l))
           (f ((Lagrange-equations L) q)))
      (se (f 't)))
    ```

    For part d, we can substitute the constant value of c to get simplified equations.

    ```scheme
    (let* ((q (up (literal-function 'x_cm)
                  (literal-function 'y_cm)
                  (literal-function 'theta)
                  (lambda (t) 'l)
                  (literal-function 'F)))
           (L (L-free-constrained-new 'm_0 'm_1 'l))
           (f ((Lagrange-equations L) q)))
      (se (f 't)))
    ```

    For part e, I wrote this in the notebook - it is effectively identical to the substitution that is happening on the computer, so I'm going to ignore this. You just get more cancellations.

6.  Exercise 1.22: Driven pendulum

7.  Exercise 1.23: Fill in the details

8.  Exercise 1.24: Constraint forces

### Constraints as Coordinate Transformations<a id="sec-1-6-3"></a>

1.  Exercise 1.25: Foucalt pendulum Lagrangian

### The Lagrangian Is Not Unique<a id="sec-1-6-4"></a>

1.  Exercise 1.26: Properties of \\(D\_t\\)

2.  Exercise 1.27: Lagrange equations for total time derivatives

3.  Exercise 1.28: Total Time Derivatives

    ```scheme
    (load "ch1/utils.scm")
    ```

    1.  part A

        nice, easy to guess.

        ```scheme
        (define ((FA m) local)
          (let ((x (coordinate local)))
            (* m x)))
        ```

        Show the function of t, and confirm that both methods are equivalent.

        ```scheme
        (check-f (FA 'm)
                 (literal-function 'x))
        ```

    2.  Part B

        NOT a total time derivative.

        Define G directly:

        ```scheme
        (define ((GB m) local)
          (let* ((t (time local))
                 (v_x (velocity local))
                 (GB0 0)
                 (GB1 (* m (cos t))))
            (+ GB0 (* GB1 v_x))))
        ```

        And show the full G, for fun:

        ```scheme
        (let ((f (compose (GB 'm) (Gamma (literal-function 'x)))))
          (se (f 't)))
        ```

        It's easier to confirm that this is not a total time derivative by checking the partials.

        ```scheme
        (define (GB-properties m)
          (let ((GB0 (lambda (local) 0))
                (GB1 (lambda (local)
                       (* m (cos (time local))))))
            (G-properties GB0 GB1 (literal-function 'x))))
        ```

        It's clear here that the second and third tuple entries aren't equal, so we don't have a total time derivative.

        ```scheme
        (se (GB-properties 'm))
        ```

    3.  Part C

        no problem, we've got a total time derivative on our hands.

        ```scheme
        (define (FC local)
          (let ((t (time local))
                (x (coordinate local)))
            (* x (cos t))))

        (check-f FC (literal-function 'x))

        (define GC-properties
          (let ((GC0 (lambda (local)
                       (* -1
                          (coordinate local)
                          (sin (time local)))))
                (GC1 (lambda (local)
                       (cos (time local)))))
            (G-properties GC0 GC1 (literal-function 'x))))
        ```

        Boom, the second and third entries are equal, as we'd expect.

        ```scheme
        (se GC-properties)
        ```

    4.  Part D

        This is NOT a total time derivative; you can tell by taking the partials of each side, G0 and G1, as we'll see here.

        ```scheme
        (define GD-properties
          (let ((GD0 (lambda (local)
                       (* (coordinate local)
                          (sin (time local)))))
                (GD1 (lambda (local)
                       (cos (time local)))))
            (G-properties GD0 GD1 (literal-function 'x))))
        ```

        The partials for each side don't match.

        ```scheme
        (se GD-properties)
        ```

    5.  Part E

        This is strange to me, because I thought that this thing had to produce a tuple.

        OH, but the secret is that Qdot is also a tuple, so you contract them together.

        Here's the function F that we can use to derive it:

        ```scheme
        (define (FE local)
          (let* ((t (time local))
                 (q (coordinate local))
                 (x (ref q 0))
                 (y (ref q 1)))
            (* (+ (square x) (square y))
               (cos t))))
        ```

        Boom, total time derivative!

        ```scheme
        (check-f FE (up (literal-function 'x)
                        (literal-function 'y)))
        ```

        And let's show that we pass the tests by decomposing this into G0 and G1:

        ```scheme
        (define GE-properties
          (let (
                ;; any piece of the function without a velocity multiplied.
                (GE0 (lambda (local)
                       (let* ((t (time local))
                              (q (coordinate local))
                              (x (ref q 0))
                              (y (ref q 1)))
                         (* -1
                            (+ (square x) (square y))
                            (sin t)))))

                ;; The pieces multiplied by velocities, split into a down tuple of
                ;; components, one for each of the coordinate components.
                (GE1 (lambda (local)
                       (let* ((t (time local))
                              (q (coordinate local))
                              (x (ref q 0))
                              (y (ref q 1)))
                         (down
                          (* 2 x (cos t))
                          (* 2 y (cos t)))))))
            (G-properties GE0 GE1 (up (literal-function 'x)
                                      (literal-function 'y)))))
        ```

        BOOM!

        We've recovered F; the partials are equal, and the final matrix is symmetric.

        ```scheme
        (se GE-properties)
        ```

    6.  Part F

        This one is interesting, since the second partial is a tuple. This is not so obvious to me, so first let's check the properties:

        ```scheme
        (define GF-properties
          (let (
                ;; any piece of the function without a velocity multiplied.
                (GF0 (lambda (local)
                       (let* ((t (time local))
                              (q (coordinate local))
                              (x (ref q 0))
                              (y (ref q 1)))
                         (* -1
                            (+ (square x) (square y))
                            (sin t)))))

                ;; The pieces multiplied by velocities, split into a down tuple of
                ;; components, one for each of the coordinate components.
                (GF1 (lambda (local)
                       (let* ((t (time local))
                              (q (coordinate local))
                              (x (ref q 0))
                              (y (ref q 1)))
                         (down
                          (+ (cube y) (* 2 x (cos t)))
                          (+ x (* 2 y (cos t))))))))
            (G-properties GF0 GF1 (up (literal-function 'x)
                                      (literal-function 'y)))))
        ```

        AND it looks like we DO have a total time derivative, maybe. We certainly pass the first test here, since the second and third tuple entries are equal.

        BUT we fail the second test; the hessian that we get from ((partial 1) G1) is not symmetric.

        ```scheme
        (se GF-properties)
        ```

4.  Exercise 1.29: Galilean Invariance

    I'll do this for a single particle, since it's annoying to get the sum going for many; and the lagrangian is additive, so no problem.

    ```scheme
    (define (uniform-translate-shift->rect local)
      (let* ((t (time local))
             (q (coordinate local))
             (xprime (ref q 0))
             (delta_x (ref q 1))
             (delta_v (ref q 2)))
        (+ xprime delta_x (* t delta_v))))

    (define (L-translate-shift m)
      (compose (L-free-particle m)
               (F->C uniform-translate-shift->rect)))
    ```

    First, confirm that if we have a constant, we get what we expected from paper.

    ```scheme
    (let* ((q (up (literal-function 'xprime)
                  (lambda (t) 'Delta_x)
                  (lambda (t) 'Delta_v)))
           (f (compose (L-translate-shift 'm) (Gamma q))))
      (->tex-equation (f 't)))
    ```

    \\[\begin{equation} {{1}\over {2}} {{\Delta}\_{v}}^{2} m + {\Delta}\_{v} m D{x}^\prime\left( t \right) + {{1}\over {2}} m {\left( D{x}^\prime\left( t \right) \right)}^{2} \end{equation}\\]

    We can change this a little to see the extra terms; substract off the free particle lagrangian, to see the extra stuff.

    ```scheme
    (let* ((q (up (literal-function 'xprime)
                  (lambda (t) 'Delta_x)
                  (lambda (t) 'Delta_v)))
           (L (- (L-translate-shift 'm)
                 (L-free-particle 'm)))
           (f (compose L (Gamma q))))
      (->tex-equation (f 't)))
    ```

    \\[\begin{equation} {{1}\over {2}} {{\Delta}\_{v}}^{2} m + {\Delta}\_{v} m D{x}^\prime\left( t \right) \end{equation}\\]

    Here's the gnarly version with both entries as actual functions. Can this be a total time derivative? It CANNOT be, because we have a \\((D \Delta\_v(t))^2\\) term in there, and we know that total time derivatives have to be linear in the velocities. The function \\(F\\) would have had to have a velocity in it, which is not allowed.

    ```scheme
    (let* ((q (up (literal-function 'xprime)
                  (literal-function 'Delta_x)
                  (literal-function 'Delta_v)))
           (L (- (L-translate-shift 'm)
                 (L-free-particle 'm)))
           (f (compose L (Gamma q))))
      (->tex-equation (f 't)))
    ```

    \\[ \begin{equation} {{1}\over {2}} m {t}^{2} {\left( D{\Delta}\_{v}\left( t \right) \right)}^{2} + m t D{x}^\prime\left( t \right) D{\Delta}\_{v}\left( t \right) + m t D{\Delta}\_{v}\left( t \right) {\Delta}\_{v}\left( t \right) + m t D{\Delta}\_{v}\left( t \right) D{\Delta}\_{x}\left( t \right) + m D{x}^\prime\left( t \right) {\Delta}\_{v}\left( t \right) + m D{x}^\prime\left( t \right) D{\Delta}\_{x}\left( t \right) - {{1}\over {2}} m {\left( D{\Delta}\_{v}\left( t \right) \right)}^{2} + {{1}\over {2}} m {\left( {\Delta}\_{v}\left( t \right) \right)}^{2} + m {\Delta}\_{v}\left( t \right) D{\Delta}\_{x}\left( t \right) \end{equation} \\]

    Let's simplify by making the \\(\Delta\_v\\) constant and see if there's anything so obvious about \\(\Delta\_x\\).

    We know that we have a total derivative when \\(\Delta\_x\\) is constant, and we know that total time derivatives are linear, so let's substract off the total time derivative and see what happens:

    ```scheme
    (let* ((q (lambda (dx)
                (up (literal-function 'xprime)
                    dx
                    (lambda (t) 'Delta_v))))
           (L (- (L-translate-shift 'm)
                 (L-free-particle 'm)))
           (f (lambda (dx)
                (compose L (Gamma (q dx))))))
      (->tex-equation
       ((- (f (literal-function 'Delta_x))
           (f (lambda (t) 'Delta_x)))
        't)))
    ```

    \\[\begin{equation} {\Delta}\_{v} m D{\Delta}\_{x}\left( t \right) + m D{x}^\prime\left( t \right) D{\Delta}\_{x}\left( t \right) \end{equation}\\]

    Take a look. there is a quadratic velocity term in here! We have \\(D \Delta\_x(t) D x'(t)\\). This is not allowed in a total time derivative.

    SO, only if the shift and uniform translation are constant do we not affect the Lagrangian value.

## Evolution of Dynamical State<a id="sec-1-7"></a>

1.  Exercise 1.30: Orbits in a central potential

2.  Exercise 1.31: Foucault pendulum evolution

## Conserved Quantities<a id="sec-1-8"></a>

### Conserved Momenta<a id="sec-1-8-1"></a>

### Energy Conservation<a id="sec-1-8-2"></a>

1.  Exercise 1.32: Time-dependent constraints

2.  Exercise 1.33: Falling off a log

### Central Forces in Three Dimensions<a id="sec-1-8-3"></a>

### The Restricted Three-Body Problem<a id="sec-1-8-4"></a>

1.  Exercise 1.34: Driven spherical pendulum

2.  Exercise 1.35: Restricted equations of motion

### Noether's Theorem<a id="sec-1-8-5"></a>

1.  Exercise 1.36: Noether integral

## Abstraction of Path Functions<a id="sec-1-9"></a>

1.  Exercise 1.37: Velocity transformation

2.  Exercise 1.38: Properties of \\(E\\)

## Constrained Motion<a id="sec-1-10"></a>

### Coordinate Constraints<a id="sec-1-10-1"></a>

1.  Exercise 1.39: Combining Lagrangians

2.  Exercise 1.40: Bead on a triaxial surface

3.  Exercise 1.41: Motion of a tiny golf ball

### Derivative Constraints<a id="sec-1-10-2"></a>

1.  Exercise 1.42: Augmented Lagrangian

### Nonholonomic Systems<a id="sec-1-10-3"></a>

## Summary<a id="sec-1-11"></a>

## Projects<a id="sec-1-12"></a>

1.  Exercise 1.43: A numerical investigation

2.  Exercise 1.44: Double pendulum behavior

# Rigid Bodies<a id="sec-2"></a>

## Rotational Kinetic Energy<a id="sec-2-1"></a>

1.  Exercise 2.1

2.  Exercise 2.2

3.  Exercise 2.3

4.  Exercise 2.4

5.  Exercise 2.5

6.  Exercise 2.6

7.  Exercise 2.7

8.  Exercise 2.8

9.  Exercise 2.9

10. Exercise 2.10

11. Exercise 2.11

12. Exercise 2.12

13. Exercise 2.13

14. Exercise 2.14

15. Exercise 2.15

16. Exercise 2.16

17. Exercise 2.17

18. Exercise 2.18

19. Exercise 2.19

20. Exercise 2.20

## Kinematics of Rotation<a id="sec-2-2"></a>

## Moments of Inertia<a id="sec-2-3"></a>

## Inertia Tensor<a id="sec-2-4"></a>

## Principal Moments of Inertia<a id="sec-2-5"></a>

## Vector Angular Momentum<a id="sec-2-6"></a>

## Euler Angles<a id="sec-2-7"></a>

## Motion of a Free Rigid Body<a id="sec-2-8"></a>

### Computing the Motion of Free Rigid Bodies<a id="sec-2-8-1"></a>

### Qualitative Features<a id="sec-2-8-2"></a>

## Euler's Equations<a id="sec-2-9"></a>

## Axisymmetric Tops<a id="sec-2-10"></a>

## Spin-Orbit Coupling<a id="sec-2-11"></a>

### Development of the Potential Energy<a id="sec-2-11-1"></a>

### Rotation of the Moon and Hyperion<a id="sec-2-11-2"></a>

### Spin-Orbit Resonances<a id="sec-2-11-3"></a>

## Nonsingular Coordinates and Quaternions<a id="sec-2-12"></a>

### Motion in Terms of Quaternions<a id="sec-2-12-1"></a>

## Summary<a id="sec-2-13"></a>

## Projects<a id="sec-2-14"></a>

# Hamiltonian Mechanics<a id="sec-3"></a>

## Hamilton's Equations<a id="sec-3-1"></a>

1.  Exercise 3.0

2.  Exercise 3.1

3.  Exercise 3.2

4.  Exercise 3.3

5.  Exercise 3.4

6.  Exercise 3.5

7.  Exercise 3.6

8.  Exercise 3.7

9.  Exercise 3.8

10. Exercise 3.9

11. Exercise 3.10

12. Exercise 3.11

13. Exercise 3.12

14. Exercise 3.13

15. Exercise 3.14

16. Exercise 3.15

17. Exercise 3.16

### The Legendre Transformation<a id="sec-3-1-1"></a>

### Hamilton's Equations from the Action Principle<a id="sec-3-1-2"></a>

### A Wiring Diagram<a id="sec-3-1-3"></a>

## Poisson Brackets<a id="sec-3-2"></a>

## One Degree of Freedom<a id="sec-3-3"></a>

## Phase Space Reduction<a id="sec-3-4"></a>

### Lagrangian Reduction<a id="sec-3-4-1"></a>

## Phase Space Evolution<a id="sec-3-5"></a>

### Phase-Space Description Is Not Unique<a id="sec-3-5-1"></a>

## Surfaces of Section<a id="sec-3-6"></a>

### Periodically Driven Systems<a id="sec-3-6-1"></a>

### Computing Stroboscopic Surfaces of Section<a id="sec-3-6-2"></a>

### Autonomous Systems<a id="sec-3-6-3"></a>

### Computing Hénon–Heiles Surfaces of Section<a id="sec-3-6-4"></a>

### Non-Axisymmetric Top<a id="sec-3-6-5"></a>

## Exponential Divergence<a id="sec-3-7"></a>

## Liouville's Theorem<a id="sec-3-8"></a>

## Standard Map<a id="sec-3-9"></a>

## Summary<a id="sec-3-10"></a>

## Projects<a id="sec-3-11"></a>

# Phase Space Structure<a id="sec-4"></a>

## Emergence of the Divided Phase Space<a id="sec-4-1"></a>

1.  Exercise 4.0

2.  Exercise 4.1

3.  Exercise 4.2

4.  Exercise 4.3

5.  Exercise 4.4

6.  Exercise 4.5

7.  Exercise 4.6

8.  Exercise 4.7

9.  Exercise 4.8

10. Exercise 4.9

11. Exercise 4.10

## Linear Stability<a id="sec-4-2"></a>

### Equilibria of Differential Equations<a id="sec-4-2-1"></a>

### Fixed Points of Maps<a id="sec-4-2-2"></a>

### Relations Among Exponents<a id="sec-4-2-3"></a>

## Homoclinic Tangle<a id="sec-4-3"></a>

### Computation of Stable and Unstable Manifolds<a id="sec-4-3-1"></a>

## Integrable Systems<a id="sec-4-4"></a>

## Poincaré–Birkhoff Theorem<a id="sec-4-5"></a>

### Computing the Poincaré–Birkhoff Construction<a id="sec-4-5-1"></a>

## Invariant Curves<a id="sec-4-6"></a>

### Finding Invariant Curves<a id="sec-4-6-1"></a>

### Dissolution of Invariant Curves<a id="sec-4-6-2"></a>

## Summary<a id="sec-4-7"></a>

## Projects<a id="sec-4-8"></a>

# Canonical Transformations<a id="sec-5"></a>

1.  Exercise 5.1

2.  Exercise 5.2

3.  Exercise 5.3

4.  Exercise 5.4

5.  Exercise 5.5

6.  Exercise 5.6

7.  Exercise 5.7

8.  Exercise 5.8

9.  Exercise 5.9

10. Exercise 5.10

11. Exercise 5.11

12. Exercise 5.12

13. Exercise 5.13

14. Exercise 5.14

15. Exercise 5.15

16. Exercise 5.16

17. Exercise 5.17

18. Exercise 5.18

19. Exercise 5.19

20. Exercise 5.20

## Point Transformations<a id="sec-5-1"></a>

## General Canonical Transformations<a id="sec-5-2"></a>

### Time-Dependent Transformations<a id="sec-5-2-1"></a>

### Abstracting the Canonical Condition<a id="sec-5-2-2"></a>

## Invariants of Canonical Transformations<a id="sec-5-3"></a>

## Generating Functions<a id="sec-5-4"></a>

### F1 Generates Canonical Transformations<a id="sec-5-4-1"></a>

### Generating Functions and Integral Invariants<a id="sec-5-4-2"></a>

### Types of Generating Functions<a id="sec-5-4-3"></a>

### Point Transformations<a id="sec-5-4-4"></a>

### Total Time Derivatives<a id="sec-5-4-5"></a>

## Extended Phase Space<a id="sec-5-5"></a>

### Poincaré–Cartan Integral Invariant<a id="sec-5-5-1"></a>

## Reduced Phase Space<a id="sec-5-6"></a>

## Summary<a id="sec-5-7"></a>

## Projects<a id="sec-5-8"></a>

# Canonical Evolution<a id="sec-6"></a>

## Hamilton–Jacobi Equation<a id="sec-6-1"></a>

1.  Exercise 6.1

2.  Exercise 6.2

3.  Exercise 6.3

4.  Exercise 6.4

5.  Exercise 6.5

6.  Exercise 6.6

7.  Exercise 6.7

8.  Exercise 6.8

9.  Exercise 6.9

10. Exercise 6.10

11. Exercise 6.11

12. Exercise 6.12

### Harmonic Oscillator<a id="sec-6-1-1"></a>

### Hamilton–Jacobi Solution of the Kepler Problem<a id="sec-6-1-2"></a>

### F2 and the Lagrangian<a id="sec-6-1-3"></a>

### The Action Generates Time Evolution<a id="sec-6-1-4"></a>

## Time Evolution is Canonical<a id="sec-6-2"></a>

### Another View of Time Evolution<a id="sec-6-2-1"></a>

### Yet Another View of Time Evolution<a id="sec-6-2-2"></a>

## Lie Transforms<a id="sec-6-3"></a>

## Lie Series<a id="sec-6-4"></a>

## Exponential Identities<a id="sec-6-5"></a>

## Summary<a id="sec-6-6"></a>

## Projects<a id="sec-6-7"></a>

# Canonical Perturbation Theory<a id="sec-7"></a>

## Perturbation Theory with Lie Series<a id="sec-7-1"></a>

1.  Exercise 7.1

2.  Exercise 7.2

3.  Exercise 7.3

4.  Exercise 7.4

5.  Exercise 7.5

## Pendulum as a Perturbed Rotor<a id="sec-7-2"></a>

### Higher Order<a id="sec-7-2-1"></a>

### Eliminating Secular Terms<a id="sec-7-2-2"></a>

## Many Degrees of Freedom<a id="sec-7-3"></a>

### Driven Pendulum as a Perturbed Rotor<a id="sec-7-3-1"></a>

## Nonlinear Resonance<a id="sec-7-4"></a>

### Pendulum Approximation<a id="sec-7-4-1"></a>

### Reading the Hamiltonian<a id="sec-7-4-2"></a>

### Resonance-Overlap Criterion<a id="sec-7-4-3"></a>

### Higher-Order Perturbation Theory<a id="sec-7-4-4"></a>

### Stability of the Inverted Vertical Equilibrium<a id="sec-7-4-5"></a>

## Summary<a id="sec-7-5"></a>

## Projects<a id="sec-7-6"></a>

# Scheme<a id="sec-8"></a>

# Our Notation<a id="sec-9"></a>

## Summary<a id="sec-9-1"></a>

Notes about this section.

## Exercises<a id="sec-9-2"></a>

Notation Appendix. This is all about getting cozy with scheme, and with the various idiosyncracies of the tuple and functional notation.

1.  Exercise 9.1 Chain Rule

    You're supposed to do these by hand, so I'll do that in the textbook. But here, let's redo them on the machine.

    1.  Compute \\(\partial\_0 F(x, y)\\) and \\(\partial\_1 F(x, y)\\)

        First, let's define the functions we need.

        ```scheme
        (define (F x y)
          (* (square x)
             (cube y)))

        (define (G x y)
          (up (F x y) y))

        (define (H x y)
          (F (F x y) y))
        ```

        You can do this with explicit partials:

        ```scheme
        (let ((f (down ((partial 0) F) ((partial 1) F))))
          (->tex-equation
           (f 'x 'y)))
        ```

        \begin{equation}
        \begin{bmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 3 {x}^{2} {y}^{2}}\end{bmatrix}
        \end{equation}

        Or with the \\(D\\) symbol:

        ```scheme
        (->tex-equation
         ((D F) 'x 'y))
        ```

        \begin{equation}
        \begin{bmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 3 {x}^{2} {y}^{2}}\end{bmatrix}
        \end{equation}

        Or, we could show that they're equivalent this way:

        ```scheme
        (let ((f (down ((partial 0) F) ((partial 1) F))))
          (->tex-equation
           (- ((D F) 'x 'y)
              (f 'x 'y))))
        ```

        \begin{equation}
        \begin{bmatrix} \displaystyle{ 0} \cr \cr \displaystyle{ 0}\end{bmatrix}
        \end{equation}

    2.  Compute \\(\partial\_0 F(F(x, y), y)\\) and \\(\partial\_1 F(F(x, y), y)\\)

        \\(H\\) is already that composition, so:

        ```scheme
        (->tex-equation
         ((D H) 'x 'y))
        ```

        \begin{equation}
        \begin{bmatrix} \displaystyle{ 4 {x}^{3} {y}^{9}} \cr \cr \displaystyle{ 9 {x}^{4} {y}^{8}}\end{bmatrix}
        \end{equation}

    3.  Compute \\(\partial\_0 G(x, y)\\) and \\(\partial\_1 G(x, y)\\)

        ```scheme
        (->tex-equation
         ((D G) 'x 'y))
        ```

        \begin{equation}
        \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 3 {x}^{2} {y}^{2}} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}
        \end{equation}

    4.  Compute \\(DF(a, b)\\), \\(DG(3, 5)\\) and \\(DH(3a^2, 5b^3)\\)

        ```scheme
        (->tex-equation
         (up ((D F) 'a 'b)
             ((D G) 3 5)
             ((D H) (* 3 (square 'a)) (* 5 (cube 'b)))))
        ```

        \begin{equation}
        \begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ 2 a {b}^{3}} \cr \cr \displaystyle{ 3 {a}^{2} {b}^{2}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 750} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 675} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ 210937500 {a}^{6} {b}^{27}} \cr \cr \displaystyle{ 284765625 {a}^{8} {b}^{24}}\end{bmatrix}}\end{pmatrix}
        \end{equation}

2.  Exercise 9.2: Computing Derivatives

    A further exercise is to try defining the functions so that they use explicit tuples, so you can compose them:

    ```scheme
    (define (F* v)
      (let ((x (ref v 0))
            (y (ref v 1)))
        (* (square x) (cube y))))

    (define (G* v)
      (let ((x (ref v 0))
            (y (ref v 1)))
        (up (F* v) y)))

    (define H* (compose F* G*))
    ```

    to be really pro, I'd make a function that takes these as arguments and prints a nice formatted exercise output. Let's do the final exercise, for fun:

    ```scheme
    (->tex-equation
     (up ((D F*) (up 'a 'b))
         ((D G*) (up 3 5))
         ((D H*) (up (* 3 (square 'a)) (* 5 (cube 'b))))))
    ```

    \begin{equation}
    \begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ 2 a {b}^{3}} \cr \cr \displaystyle{ 3 {a}^{2} {b}^{2}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 750} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 675} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ 210937500 {a}^{6} {b}^{27}} \cr \cr \displaystyle{ 284765625 {a}^{8} {b}^{24}}\end{bmatrix}}\end{pmatrix}
    \end{equation}

# Org-Mode Demo<a id="sec-10"></a>

This is an example of how we might structure an org-mode file that can export out to Github flavored Markdown, or to a PDF.

First, let's get some code loaded up and written. Here's a block that converts polar coordinates to rectangular coordinates.

```scheme
(define (p->r local)
  (let* ((polar-tuple (coordinate local))
         (r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))
```

This is some good stuff.

```scheme
(load "ch1/utils.scm")

(define (p->r local)
  (let* ((polar-tuple (coordinate local))
         (r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))

(define (spherical->rect local)
  (let* ((spherical-tuple (coordinate local))
         (r (ref spherical-tuple 0))
         (theta (ref spherical-tuple 1))
         (phi (ref spherical-tuple 2)))
    (up (* r (sin theta) (cos phi))
        (* r (sin theta) (sin phi))
        (* r (cos theta)))))
```

And another, that gets us from spherical to rectangular.

```scheme
(define (spherical->rect local)
  (let* ((spherical-tuple (coordinate local))
         (r (ref spherical-tuple 0))
         (theta (ref spherical-tuple 1))
         (phi (ref spherical-tuple 2)))
    (up (* r (sin theta) (cos phi))
        (* r (sin theta) (sin phi))
        (* r (cos theta)))))
```

    ;Loading "ch1/utils.scm"... done
    #| "" |#

This block will generate a LaTeX version of the code I've supplied:

```scheme
(->tex-equation
 ((+ (literal-function 'c)
     (D (literal-function 'z)))
  't)
 "eq:masterpiece")
```

\begin{equation}
c\left( t \right) + Dz\left( t \right)
\label{eq:masterpiece}
\end{equation}

You can even reference these with equation numbers, like Equation \eqref{eq:masterpiece} above.

```scheme
(up 1 2 't)
```

    #|
    (up 1 2 t)
    |#

### Equations<a id="sec-10-0-1"></a>

Here's (a test) of \\(a = bc\\) and more \\[ \alpha\_t \\] equations:

And again this is a thing:

\\[ e^{i\pi} = -1 \\]

\\[ \int\_0^\infty e^{-x^2} dx = \frac{\sqrt{\pi}}{2} \\]

\\(\vec{x} \dot (\vec{x} \times \vec{v}) = \vec{v} \dot (\vec{x} \times \vec{v}) = 0\\)

\\(\vec{x} \cdot (\vec{x} \times \vec{v}) = \vec{v} \dot (\vec{x} \times \vec{b}) = 0\\)
