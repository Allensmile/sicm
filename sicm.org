# -*- eval: (org-num-mode 1); -*-
#+title: Structure and Interpretation of Classical Mechanics
#+subtitle: Computational Physics!
#+startup: indent num
#+date: 2020-05-26

Welcome to my tour of Structure and Interpretation of Classical Mechanics. I'm
working on this book to develop my sense of the best way to do research in
public; this book is heavy on math, programming and visualization, and should
stress the normal tools.

I'm attempting to take notes in on org-mode file, and generate all my code from
there. Let's see how it goes!

* Lagrangian Mechanics
  :PROPERTIES:
  :header-args: :eval no-export
  :EXPORT_FILE_NAME: md/1_lagrangian_mechanics
  :END:

** Configuration Spaces

Discuss the section here. This is a test of a new heading style.

Here's a nice image of some action getting minimized:

[[https://i.imgur.com/AJBpDgU.gif]]

**** Exercise 1.1, p5 and 1.2, p8

For each of the mechanical systems described below, give the number of degrees
of freedom of the configuration space.

(Exercise 1.2 asks about the generalized coordinates of each, so I'll note those
here too.)

1. Three juggling pins.

   **18 degrees of freedom** for three juggling pins - 3 position, 3 angles for
   each. OR **15** total, if you assume that the pin is symmetric; then you just
   need two degrees of tilt.

2. A spherical pendulum consisting of a point mass (the pendulum bob) hanging
   from a rigid massless rod attached to a fixed support point. The pendulum bob
   may move in any direction subject to the constraint imposed by the rigid rod.
   The point mass is subject to the uniform force of gravity.

   Spherical pendulum,hanging from a fixed support has **two degrees of
   freedom**, one for each angle.

3. Spherical DOUBLE pendulum has **four degrees of freedom**; two angles from
   previous, plus two more angles for the second pendulum off of the first.

   A spherical double pendulum, consisting of one point mass hanging from a
   rigid massless rod attached to a second point mass hanging from a second
   massless rod attached to a fixed support point. The point masses are subject
   to the uniform force of gravity.

4. A point mass sliding without friction on a rigid curved wire.

   **1 degree of freedom**, distance along the wire.

5. A top consisting of a rigid axisymmetric body with one point on the symmetry
   axis of the body attached to a fixed support, subject to a uniform
   gravitational force.

   Axisymmetric top has **TWO degrees of freedom**, for the angles off of
   vertical. But then we can't talk about its speed, so that's a little strange.
   I guess it has an angular momentum as a property, but that's not a
   coordinate.

6. The same as e, but not axisymmetric.

   We now have **THREE degrees of freedom**, one more for the angle of the top's
   rotation.

** Generalized Coordinates

**** Exercise 1.3

Fermat Optics. It's in the foldede section in the blue notebook. Do it again!

**** Exercise 1.4
**** Exercise 1.5
**** Exercise 1.6
**** Exercise 1.7
**** Exercise 1.8: Implementing Delta
:PROPERTIES:
:header-args+: :tangle ch1/ex1-8.scm :comments org
:END:

This FEELS weird... but we want something that is... well, let's see.

#+begin_src scheme
(define (((delta eta) f) q)
  (let (g (lambda (eps)
            (f (q + (* eps eta)))))
    ((D g) 0)))
#+end_src

Why does this work? WELL... we need a way to force the limit in.

this is a PATH function, remember. This takes a path function, then passes it
into $\Gamma$, and composes THAT with F. F is a function from the local tuple to
some output variable. You can imagine it as the Langrangian, for example.

The local tuple type defined here can take any number of path components.

#+begin_src scheme
(define (f q)
  (let* ((Local (Up Real (UP* Real) (UP* Real)))
         (F (literal-function 'F (-> Local Real))))
    (compose F (Gamma q))))
#+end_src

This is a path function that returns a 2d path; we can use this as an example.

#+begin_src scheme
(define q (literal-function 'q (-> Real (Up Real Real))))
#+end_src


**** Exercise 1.9
**** Exercise 1.10
**** Exercise 1.11
**** Exercise 1.12
**** Exercise 1.13
**** Exercise 1.14
**** Exercise 1.15
:PROPERTIES:
:header-args+: :tangle ch1/ex1-15.scm :comments org
:END:

This one was a serious doozy. I plan on going through and co

Checking that composition distributes over multiplication...

#+begin_src scheme
(define f (literal-function 'f))
(define g (literal-function 'g))
(define h (literal-function 'h))
#+end_src

looks good! These are the same expression.

#+begin_src scheme
((compose (* f g) h) 't)
((* (compose f h) (compose g h)) 't)
#+end_src

 This is the general form of a path transformation; big surprise, this is very
 close to the code on page 46. I'm going to keep my version, since I don't want
 to get too confused, here.

#+begin_src scheme
(define ((F->C F) local)
  (let ((t (time local))
        (x (coordinate local))
        (v (velocity local)))
    (up t
        (F t x)
        (+ (((partial 0) F) t x)
           (* (((partial 1) F) t x)
              v)))))
#+end_src

Here's a literal function we can play with.

#+begin_src scheme
(define F*
  (literal-function 'F (-> (X Real Real) Real)))
#+end_src

Okay, boom, this is the literal function.

#+begin_src scheme
(define q-prime
  (literal-function 'q-prime))
#+end_src

This is the manual generation of q from q-prime.

#+begin_src scheme
(define ((to-q F) qp)
  (lambda (t) (F t (qp t))))
#+end_src

We can check that these are now equal. This uses C to get us to q

#+begin_src scheme
((compose (F->C F*) (Gamma q-prime)) 't)
#+end_src

And this does it by passing in q manually.

#+begin_src scheme
((Gamma ((to-q F*) q-prime)) 't)
#+end_src

I can convert the proof to code, no problem, by showing that these sides are equal.

YES!! the final step of my proof was the note that these are equal. THIS IS
HUGE!!!

#+begin_src scheme
((compose (lambda (x) (ref x 1)) ((partial 1) (F->C F*)) (Gamma q-prime)) 't)
((compose (lambda (x) (ref x 2)) ((partial 2) (F->C F*)) (Gamma q-prime)) 't)
#+end_src

Just for fun, note that this successfully pushes things inside gamma.

#+begin_src scheme
(let ((L (literal-function 'L (-> (UP Real Real Real) Real)))
      (C (F->C F*)))
  ((Gamma ((to-q ((partial 1) F*)) q-prime)) 't))

(define (p->r t polar-tuple)
  (let* ((r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))

(literal-function 'q-prime (-> Real (UP Real Real)))((Gamma ((to-q p->r) )) 't)
#+end_src


trying again. get a function:

#+begin_src scheme
(define q
  ;; time to x y.
  (literal-function 'q (-> Real (UP Real Real))))

(define (C local)
  (up (time local)
     (square (coordinate local))
     (velocity local)))

((compose C (Gamma q)) 't)
#+end_src

That's good for now.

**** Exercise 1.16
:PROPERTIES:
:header-args+: :tangle ch1/ex1-16.scm :comments org
:END:

Messing around to make sure I understand what I'm seeing in the coordinate
transforms on page 45.

#+begin_src scheme
(load "ch1/utils.scm")

(define (p->r local)
  (let* ((polar-tuple (coordinate local))
         (r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))

(define (spherical->rect local)
  (let* ((spherical-tuple (coordinate local))
         (r (ref spherical-tuple 0))
         (theta (ref spherical-tuple 1))
         (phi (ref spherical-tuple 2)))
    (up (* r (sin theta) (cos phi))
        (* r (sin theta) (sin phi))
        (* r (cos theta)))))
#+end_src

Check polar:

#+begin_src scheme
(show-expression
 ((F->C p->r)
  (up 't
      (up 'r 'phi)
      (up 'rdot 'phidot))))
#+end_src

spherical coordinate change, check velocities:

#+begin_src scheme
(show-expression
 ((F->C spherical->rect)
  (up 't
      (up 'r 'theta 'phi)
      (up 'rdot 'thetadot 'phidot))))

(show-expression
 (square (ref (ref ((F->C spherical->rect)
             (up 't
                 (up 'r 'theta 'phi)
                 (up 'rdot 'thetadot 'phidot))) 2) 0)))
#+end_src

get the Langrangian from page 41:

#+begin_src scheme
(define ((L-central-rectangular m U) local)
  (let ((q (coordinate local))
        (v (velocity local)))
    (- (* 1/2 m (square v))
       (U (sqrt (square q))))))
#+end_src

BOOM, now we can compose these things!

#+begin_src scheme
(define (L-central-polar m U)
  (compose (L-central-rectangular m U)
           (F->C p->r)))

(define (L-central-spherical m U)
  (compose (L-central-rectangular m U)
           (F->C spherical->rect)))
#+end_src

Confirm the polar coordinate version...

#+begin_src scheme
(show-expression
 ((L-central-polar 'm (literal-function 'U))
  (up 't
      (up 'r 'phi)
      (up 'rdot 'phidot))))
#+end_src

BOOM, much better than calculating by hand!

#+begin_src scheme
(show-expression
 ((L-central-spherical 'm (literal-function 'U))
  (up 't
      (up 'r 'theta 'phi)
      (up 'rdot 'thetadot 'phidot))))
#+end_src


rectangular, for fun:

#+begin_src scheme
(show-expression
 ((L-central-rectangular 'm (literal-function 'U))
  (up 't
      (up 'x 'y 'z)
      (up 'xdot 'ydot 'zdot))))
#+end_src

**** Exercise 1.17
**** Exercise 1.18
**** Exercise 1.19
**** Exercise 1.20
**** Exercise 1.21
:PROPERTIES:
:header-args+: :tangle ch1/ex1-21.scm :comments org
:END:

The uneven dumbbell, 1.21.

#+begin_src scheme
(load "ch1/utils.scm")
#+end_src

Takes in any number of up tuples and zips them into a new list of up-tuples by
taking each element.

#+begin_src scheme
(define (up-zip . ups)
  (apply vector-map up (map up->vector ups)))
#+end_src

I spent some time trying to make a nice API... but without map, filter,
reduce etc on tuples it is quite annoying. So let's go ad hoc first and see
what happens.

#+begin_src scheme
(define (KE-particle m v)
  (* 1/2 m (square v)))
#+end_src

#+begin_src scheme
;; gets the particle itself
(define ((extract-particle pieces) local i)
  (let* ((q (coordinate local))
         (qdot (velocity local))
         (indices (apply up (iota pieces (* i pieces))))
         (extract (lambda (tuple)
                    (vector-map (lambda (i) (ref tuple i))
                                indices))))
    (up (time q)
        (extract q)
        (extract qdot))))

(define (constraint q0 q1 F l)
  (* (/ F (* 2 l))
     (- (square (- q1 q0))
        (square l))))

(define ((L-free-constrained m0 m1 l) local)
  (let* ((extract (extract-particle 2))
         (p0 (extract local 0))
         (q_0 (coordinate p0))
         (qdot_0 (velocity p0))

         (p1 (extract local 1))
         (q_1 (coordinate p1))
         (qdot_1 (velocity p1))

         (F (ref (coordinate local) 4)))
    (- (+ (KE-particle m0 qdot_0)
          (KE-particle m1 qdot_1))
       (constraint q_0 q_1 F l))))

(define q-rect
  (up (literal-function 'x_0)
      (literal-function 'y_0)
      (literal-function 'x_1)
      (literal-function 'y_1)
      (literal-function 'F)))
#+end_src

This shows the lagrangian itself, which answers part b:

#+begin_src scheme
(let* ((L (L-free-constrained 'm_0 'm_1 'l))
       (f (compose L (Gamma q-rect))))
  (se (f 't)))
#+end_src

Here are the lagrange equations, confirming part b.

#+begin_src scheme
(let* ((L (L-free-constrained 'm_0 'm_1 'l))
       (f ((Lagrange-equations L) q-rect)))
  (se (f 't)))
#+end_src

Part c - make a change of coordinates.

#+begin_src scheme
(define ((cm-theta->rect m0 m1) local)
  (let* ((q (coordinate local))
         (x_cm (ref q 0))
         (y_cm (ref q 1))
         (theta (ref q 2))
         (c (ref q 3))
         (F (ref q 4))
         (total-mass (+ m0 m1))
         (m0-distance (* c (/ m1 total-mass)))
         (m1-distance (* c (/ m0 total-mass))))
    (up (- x_cm (* m0-distance (cos theta)))
        (- y_cm (* m0-distance (sin theta)))
        (+ x_cm (* m1-distance (cos theta)))
        (+ y_cm (* m1-distance (sin theta)))
        F)))

(se
 ((F->C (cm-theta->rect 'm_0 'm_1))
  (up 't
      (up 'x_cm 'y_cm 'theta 'c 'F)
      (up 'xdot_cm 'ydot_cm 'thetadot 'cdot 'Fdot))))

(define (L-free-constrained-new m0 m1 l)
  (compose (L-free-constrained m0 m1 l)
           (F->C (cm-theta->rect m0 m1))))
#+end_src

This shows the lagrangian itself, after the coordinate transformation:

#+begin_src scheme
(let* ((q (up (literal-function 'x_cm)
              (literal-function 'y_cm)
              (literal-function 'theta)
              (literal-function 'c)
              (literal-function 'F)))
       (L (L-free-constrained-new 'm_0 'm_1 'l))
       (f (compose L (Gamma q))))
  (se (f 't)))
#+end_src

Here are the lagrange equations for part c.

#+begin_src scheme
(let* ((q (up (literal-function 'x_cm)
              (literal-function 'y_cm)
              (literal-function 'theta)
              (literal-function 'c)
              (literal-function 'F)))
       (L (L-free-constrained-new 'm_0 'm_1 'l))
       (f ((Lagrange-equations L) q)))
  (se (f 't)))
#+end_src

For part d, we can substitute the constant value of c to get simplified
equations.

#+begin_src scheme
(let* ((q (up (literal-function 'x_cm)
              (literal-function 'y_cm)
              (literal-function 'theta)
              (lambda (t) 'l)
              (literal-function 'F)))
       (L (L-free-constrained-new 'm_0 'm_1 'l))
       (f ((Lagrange-equations L) q)))
  (se (f 't)))
#+end_src

For part e, I wrote this in the notebook - it is effectively identical to the
substitution that is happening on the computer, so I'm going to ignore this. You
just get more cancellations.

**** Exercise 1.22
**** Exercise 1.23
**** Exercise 1.24
**** Exercise 1.25
**** Exercise 1.26
**** Exercise 1.27
**** Exercise 1.28: Total Time Derivatives
:PROPERTIES:
:header-args+: :tangle ch1/ex1-28.scm :comments org
:END:

#+begin_src scheme
(load "ch1/utils.scm")
#+end_src

***** part A

nice, easy to guess.

#+begin_src scheme
(define ((FA m) local)
  (let ((x (coordinate local)))
    (* m x)))
#+end_src

Show the function of t, and confirm that both methods are equivalent.

#+begin_src scheme
(check-f (FA 'm)
         (literal-function 'x))
#+end_src

***** Part B

NOT a total time derivative.

Define G directly:

#+begin_src scheme
(define ((GB m) local)
  (let* ((t (time local))
         (v_x (velocity local))
         (GB0 0)
         (GB1 (* m (cos t))))
    (+ GB0 (* GB1 v_x))))
#+end_src

And show the full G, for fun:

#+begin_src scheme
(let ((f (compose (GB 'm) (Gamma (literal-function 'x)))))
  (se (f 't)))
#+end_src


It's easier to confirm that this is not a total time derivative by checking the
partials.

#+begin_src scheme
(define (GB-properties m)
  (let ((GB0 (lambda (local) 0))
        (GB1 (lambda (local)
               (* m (cos (time local))))))
    (G-properties GB0 GB1 (literal-function 'x))))
#+end_src

It's clear here that the second and third tuple entries aren't equal, so we
don't have a total time derivative.

#+begin_src scheme
(se (GB-properties 'm))
#+end_src

***** Part C

no problem, we've got a total time derivative on our hands.

#+begin_src scheme
(define (FC local)
  (let ((t (time local))
        (x (coordinate local)))
    (* x (cos t))))

(check-f FC (literal-function 'x))

(define GC-properties
  (let ((GC0 (lambda (local)
               (* -1
                  (coordinate local)
                  (sin (time local)))))
        (GC1 (lambda (local)
               (cos (time local)))))
    (G-properties GC0 GC1 (literal-function 'x))))
#+end_src

Boom, the second and third entries are equal, as we'd expect.

#+begin_src scheme
(se GC-properties)
#+end_src


***** Part D

This is NOT a total time derivative; you can tell by taking the partials
of each side, G0 and G1, as we'll see here.

#+begin_src scheme
(define GD-properties
  (let ((GD0 (lambda (local)
               (* (coordinate local)
                  (sin (time local)))))
        (GD1 (lambda (local)
               (cos (time local)))))
    (G-properties GD0 GD1 (literal-function 'x))))
#+end_src

The partials for each side don't match.

#+begin_src scheme
(se GD-properties)
#+end_src

***** Part E

This is strange to me, because I thought that this thing had to produce a tuple.

OH, but the secret is that Qdot is also a tuple, so you contract them together.

Here's the function F that we can use to derive it:

#+begin_src scheme
(define (FE local)
  (let* ((t (time local))
         (q (coordinate local))
         (x (ref q 0))
         (y (ref q 1)))
    (* (+ (square x) (square y))
       (cos t))))
#+end_src

Boom, total time derivative!

#+begin_src scheme
(check-f FE (up (literal-function 'x)
                (literal-function 'y)))
#+end_src

And let's show that we pass the tests by decomposing this into G0 and G1:

#+begin_src scheme
(define GE-properties
  (let (
        ;; any piece of the function without a velocity multiplied.
        (GE0 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (* -1
                    (+ (square x) (square y))
                    (sin t)))))

        ;; The pieces multiplied by velocities, split into a down tuple of
        ;; components, one for each of the coordinate components.
        (GE1 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (down
                  (* 2 x (cos t))
                  (* 2 y (cos t)))))))
    (G-properties GE0 GE1 (up (literal-function 'x)
                              (literal-function 'y)))))
#+end_src

BOOM!

We've recovered F; the partials are equal, and the final matrix is symmetric.

#+begin_src scheme
(se GE-properties)
#+end_src

***** Part F

This one is interesting, since the second partial is a tuple. This is not so
obvious to me, so first let's check the properties:

#+begin_src scheme
(define GF-properties
  (let (
        ;; any piece of the function without a velocity multiplied.
        (GF0 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (* -1
                    (+ (square x) (square y))
                    (sin t)))))

        ;; The pieces multiplied by velocities, split into a down tuple of
        ;; components, one for each of the coordinate components.
        (GF1 (lambda (local)
               (let* ((t (time local))
                      (q (coordinate local))
                      (x (ref q 0))
                      (y (ref q 1)))
                 (down
                  (+ (cube y) (* 2 x (cos t)))
                  (+ x (* 2 y (cos t))))))))
    (G-properties GF0 GF1 (up (literal-function 'x)
                              (literal-function 'y)))))
#+end_src

AND it looks like we DO have a total time derivative, maybe. We certainly pass
the first test here, since the second and third tuple entries are equal.

BUT we fail the second test; the hessian that we get from ((partial 1) G1) is
not symmetric.

#+begin_src scheme
(se GF-properties)
#+end_src


**** Exercise 1.29: Galilean Invariance
:PROPERTIES:
:header-args+: :tangle ch1/ex1-29.scm :comments org
:END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

I'll do this for a single particle, since it's annoying to get the sum going
for many; and the lagrangian is additive, so no problem.

#+begin_src scheme
(define (uniform-translate-shift->rect local)
  (let* ((t (time local))
         (q (coordinate local))
         (xprime (ref q 0))
         (delta_x (ref q 1))
         (delta_v (ref q 2)))
    (+ xprime delta_x (* t delta_v))))

(define (L-translate-shift m)
  (compose (L-free-particle m)
           (F->C uniform-translate-shift->rect)))
#+end_src

#+RESULTS:
: #| uniform-translate-shift->rect |#
:
: #| L-translate-shift |#

First, confirm that if we have a constant, we get what we expected from paper.

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (up (literal-function 'xprime)
              (lambda (t) 'Delta_x)
              (lambda (t) 'Delta_v)))
       (f (compose (L-translate-shift 'm) (Gamma q))))
  (->tex-equation (f 't)))
#+end_src

#+RESULTS[5d2b4de08cfab4779bf7cdab31d518191b40a4d2]:
\begin{equation}
{{1}\over {2}} {{\Delta}_{v}}^{2} m + {\Delta}_{v} m D{x}^\prime\left( t \right) + {{1}\over {2}} m {\left( D{x}^\prime\left( t \right) \right)}^{2}
\end{equation}

We can change this a little to see the extra terms; substract off the free
particle lagrangian, to see the extra stuff.

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (up (literal-function 'xprime)
              (lambda (t) 'Delta_x)
              (lambda (t) 'Delta_v)))
       (L (- (L-translate-shift 'm)
             (L-free-particle 'm)))
       (f (compose L (Gamma q))))
  (->tex-equation (f 't)))
#+end_src

#+RESULTS[c17004e61fec7edb3835203cdc99c562940bee7c]:
\begin{equation}
{{1}\over {2}} {{\Delta}_{v}}^{2} m + {\Delta}_{v} m D{x}^\prime\left( t \right)
\end{equation}

Here's the gnarly version with both entries as actual functions. Can this be a
total time derivative? It CANNOT be, because we have a $(D \Delta_v(t))^2$ term
in there, and we know that total time derivatives have to be linear in the
velocities. The function $F$ would have had to have a velocity in it, which is
not allowed.

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (up (literal-function 'xprime)
              (literal-function 'Delta_x)
              (literal-function 'Delta_v)))
       (L (- (L-translate-shift 'm)
             (L-free-particle 'm)))
       (f (compose L (Gamma q))))
  (->tex-equation (f 't)))
#+end_src

#+RESULTS[ded4f6dec25954c9b7536153e1db8db0315cb399]:
\begin{equation}
{{1}\over {2}} m {t}^{2} {\left( D{\Delta}_{v}\left( t \right) \right)}^{2} + m t D{x}^\prime\left( t \right) D{\Delta}_{v}\left( t \right) + m t D{\Delta}_{v}\left( t \right) {\Delta}_{v}\left( t \right) + m t D{\Delta}_{v}\left( t \right) D{\Delta}_{x}\left( t \right) + m D{x}^\prime\left( t \right) {\Delta}_{v}\left( t \right) + m D{x}^\prime\left( t \right) D{\Delta}_{x}\left( t \right) - {{1}\over {2}} m {\left( D{\Delta}_{v}\left( t \right) \right)}^{2} + {{1}\over {2}} m {\left( {\Delta}_{v}\left( t \right) \right)}^{2} + m {\Delta}_{v}\left( t \right) D{\Delta}_{x}\left( t \right)
\end{equation}

Let's simplify by making the $\Delta_v$ constant and see if there's anything so
obvious about $\Delta_x$.

We know that we have a total derivative when $\Delta_x$ is constant, and we know
that total time derivatives are linear, so let's substract off the total time
derivative and see what happens:

#+begin_src scheme :results value raw :exports both :cache yes
(let* ((q (lambda (dx)
            (up (literal-function 'xprime)
                dx
                (lambda (t) 'Delta_v))))
       (L (- (L-translate-shift 'm)
             (L-free-particle 'm)))
       (f (lambda (dx)
            (compose L (Gamma (q dx))))))
  (->tex-equation
   ((- (f (literal-function 'Delta_x))
       (f (lambda (t) 'Delta_x)))
    't)))
#+end_src

#+RESULTS[1a9463beb2f26c1661f1978633ca830ba12f73ec]:
\begin{equation}
{\Delta}_{v} m D{\Delta}_{x}\left( t \right) + m D{x}^\prime\left( t \right) D{\Delta}_{x}\left( t \right)
\end{equation}

Take a look. there is a quadratic velocity term in here! We have $D \Delta_x(t)
D x'(t)$. This is not allowed in a total time derivative.

SO, only if the shift and uniform translation are constant do we not affect the
Lagrangian value.

**** Exercise 1.30
**** Exercise 1.31
**** Exercise 1.32
**** Exercise 1.33
**** Exercise 1.34
**** Exercise 1.35
**** Exercise 1.36
**** Exercise 1.37
**** Exercise 1.38
**** Exercise 1.39
**** Exercise 1.40
**** Exercise 1.41
**** Exercise 1.42
**** Exercise 1.43
**** Exercise 1.44

** The Principle of Stationary Action
** Computing Actions
** The Euler–Lagrange Equations
*** Derivation of the Lagrange Equations
*** Computing Lagrange's Equations
** How to Find Lagrangians
*** Coordinate Transformations
*** Systems with Rigid Constraints
*** Constraints as Coordinate Transformations
*** The Lagrangian Is Not Unique
** Evolution of Dynamical State
** Conserved Quantities
*** Conserved Momenta
*** Energy Conservation
*** Central Forces in Three Dimensions
*** The Restricted Three-Body Problem
*** Noether's Theorem
** Abstraction of Path Functions
** Constrained Motion
*** Coordinate Constraints
*** Derivative Constraints
*** Nonholonomic Systems
** Summary
** Projects
* Rigid Bodies
** Rotational Kinetic Energy

**** Exercise 2.1
**** Exercise 2.2
**** Exercise 2.3
**** Exercise 2.4
**** Exercise 2.5
**** Exercise 2.6
**** Exercise 2.7
**** Exercise 2.8
**** Exercise 2.9
**** Exercise 2.10
**** Exercise 2.11
**** Exercise 2.12
**** Exercise 2.13
**** Exercise 2.14
**** Exercise 2.15
**** Exercise 2.16
**** Exercise 2.17
**** Exercise 2.18
**** Exercise 2.19
**** Exercise 2.20

** Kinematics of Rotation
** Moments of Inertia
** Inertia Tensor
** Principal Moments of Inertia
** Vector Angular Momentum
** Euler Angles
** Motion of a Free Rigid Body
*** Computing the Motion of Free Rigid Bodies
*** Qualitative Features
** Euler's Equations
** Axisymmetric Tops
** Spin-Orbit Coupling
*** Development of the Potential Energy
*** Rotation of the Moon and Hyperion
*** Spin-Orbit Resonances
** Nonsingular Coordinates and Quaternions
*** Motion in Terms of Quaternions
** Summary
** Projects
* Hamiltonian Mechanics
** Hamilton's Equations

**** Exercise 3.0
**** Exercise 3.1
**** Exercise 3.2
**** Exercise 3.3
**** Exercise 3.4
**** Exercise 3.5
**** Exercise 3.6
**** Exercise 3.7
**** Exercise 3.8
**** Exercise 3.9
**** Exercise 3.10
**** Exercise 3.11
**** Exercise 3.12
**** Exercise 3.13
**** Exercise 3.14
**** Exercise 3.15
**** Exercise 3.16

*** The Legendre Transformation
*** Hamilton's Equations from the Action Principle
*** A Wiring Diagram
** Poisson Brackets
** One Degree of Freedom
** Phase Space Reduction
*** Lagrangian Reduction
** Phase Space Evolution
*** Phase-Space Description Is Not Unique
** Surfaces of Section
*** Periodically Driven Systems
*** Computing Stroboscopic Surfaces of Section
*** Autonomous Systems
*** Computing Hénon–Heiles Surfaces of Section
*** Non-Axisymmetric Top
** Exponential Divergence
** Liouville's Theorem
** Standard Map
** Summary
** Projects
* Phase Space Structure
** Emergence of the Divided Phase Space

**** Exercise 4.0
**** Exercise 4.1
**** Exercise 4.2
**** Exercise 4.3
**** Exercise 4.4
**** Exercise 4.5
**** Exercise 4.6
**** Exercise 4.7
**** Exercise 4.8
**** Exercise 4.9
**** Exercise 4.10

** Linear Stability
*** Equilibria of Differential Equations
*** Fixed Points of Maps
*** Relations Among Exponents
** Homoclinic Tangle
*** Computation of Stable and Unstable Manifolds
** Integrable Systems
** Poincaré–Birkhoff Theorem
*** Computing the Poincaré–Birkhoff Construction
** Invariant Curves
*** Finding Invariant Curves
*** Dissolution of Invariant Curves
** Summary
** Projects
* Canonical Transformations

**** Exercise 5.1
**** Exercise 5.2
**** Exercise 5.3
**** Exercise 5.4
**** Exercise 5.5
**** Exercise 5.6
**** Exercise 5.7
**** Exercise 5.8
**** Exercise 5.9
**** Exercise 5.10
**** Exercise 5.11
**** Exercise 5.12
**** Exercise 5.13
**** Exercise 5.14
**** Exercise 5.15
**** Exercise 5.16
**** Exercise 5.17
**** Exercise 5.18
**** Exercise 5.19
**** Exercise 5.20

** Point Transformations
** General Canonical Transformations
*** Time-Dependent Transformations
*** Abstracting the Canonical Condition
** Invariants of Canonical Transformations
** Generating Functions
*** F1 Generates Canonical Transformations
*** Generating Functions and Integral Invariants
*** Types of Generating Functions
*** Point Transformations
*** Total Time Derivatives
** Extended Phase Space
*** Poincaré–Cartan Integral Invariant
** Reduced Phase Space
** Summary
** Projects
* Canonical Evolution

** Hamilton–Jacobi Equation

**** Exercise 6.1
**** Exercise 6.2
**** Exercise 6.3
**** Exercise 6.4
**** Exercise 6.5
**** Exercise 6.6
**** Exercise 6.7
**** Exercise 6.8
**** Exercise 6.9
**** Exercise 6.10
**** Exercise 6.11
**** Exercise 6.12

*** Harmonic Oscillator
*** Hamilton–Jacobi Solution of the Kepler Problem
*** F2 and the Lagrangian
*** The Action Generates Time Evolution
** Time Evolution is Canonical
*** Another View of Time Evolution
*** Yet Another View of Time Evolution
** Lie Transforms
** Lie Series
** Exponential Identities
** Summary
** Projects
* Canonical Perturbation Theory

** Perturbation Theory with Lie Series

**** Exercise 7.1
**** Exercise 7.2
**** Exercise 7.3
**** Exercise 7.4
**** Exercise 7.5

** Pendulum as a Perturbed Rotor
*** Higher Order
*** Eliminating Secular Terms
** Many Degrees of Freedom
*** Driven Pendulum as a Perturbed Rotor
** Nonlinear Resonance
*** Pendulum Approximation
*** Reading the Hamiltonian
*** Resonance-Overlap Criterion
*** Higher-Order Perturbation Theory
*** Stability of the Inverted Vertical Equilibrium
** Summary
** Projects
* Scheme
* Our Notation
  :PROPERTIES:
  :header-args: :eval never-export
  :END:

** Summary

Notes about this section.

** Exercises

Notation Appendix. This is all about getting cozy with scheme, and with the
various idiosyncracies of the tuple and functional notation.

**** Exercise 9.1 Chain Rule
     :PROPERTIES:
     :header-args+: :tangle ch9/ex9-1.scm :comments org
     :END:

You're supposed to do these by hand, so I'll do that in the textbook. But here,
let's redo them on the machine.

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

#+RESULTS:
: ;Loading "ch1/utils.scm"...
: ;  Loading "ch1/exdisplay.scm"... done
: ;... done
: #| check-f |#

***** Compute $\partial_0 F(x, y)$ and $\partial_1 F(x, y)$

First, let's define the functions we need.

#+begin_src scheme
(define (F x y)
  (* (square x)
     (cube y)))

(define (G x y)
  (up (F x y) y))

(define (H x y)
  (F (F x y) y))
#+end_src

#+RESULTS:
: #| F |#
:
: #| G |#
:
: #| H |#

 You can do this with explicit partials:

#+begin_src scheme :results value raw :exports both :cache yes
(let ((f (down ((partial 0) F) ((partial 1) F))))
  (->tex-equation
   (f 'x 'y)))
#+end_src

#+RESULTS[b8eaf52d98e5903b52306509dcdc8f8eeb97144c]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 3 {x}^{2} {y}^{2}}\end{bmatrix}
\end{equation}

Or with the $D$ symbol:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((D F) 'x 'y))
#+end_src

#+RESULTS[f3fba605ac97a3ebd30b4a96aca31eed921e2e93]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 3 {x}^{2} {y}^{2}}\end{bmatrix}
\end{equation}

Or, we could show that they're equivalent this way:

#+begin_src scheme :results value raw :exports both :cache yes
(let ((f (down ((partial 0) F) ((partial 1) F))))
  (->tex-equation
   (- ((D F) 'x 'y)
      (f 'x 'y))))
#+end_src

#+RESULTS[bbfc31a98ddca1b434403a34cefb730e354f1be8]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 0} \cr \cr \displaystyle{ 0}\end{bmatrix}
\end{equation}

***** Compute $\partial_0 F(F(x, y), y)$ and $\partial_1 F(F(x, y), y)$

$H$ is already that composition, so:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((D H) 'x 'y))
#+end_src

#+RESULTS[22a0dfcbcf713d36b0f899b6baac6dbf1ec4b56d]:
\begin{equation}
\begin{bmatrix} \displaystyle{ 4 {x}^{3} {y}^{9}} \cr \cr \displaystyle{ 9 {x}^{4} {y}^{8}}\end{bmatrix}
\end{equation}

***** Compute $\partial_0 G(x, y)$ and $\partial_1 G(x, y)$

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((D G) 'x 'y))
#+end_src

#+RESULTS[548f447f81ffe817f686965fb5fdc1d0cbecc5f9]:
\begin{equation}
\begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 2 x {y}^{3}} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 3 {x}^{2} {y}^{2}} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}
\end{equation}

***** Compute $DF(a, b)$, $DG(3, 5)$ and $DH(3a^2, 5b^3)$

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 (up ((D F) 'a 'b)
     ((D G) 3 5)
     ((D H) (* 3 (square 'a)) (* 5 (cube 'b)))))
#+end_src

#+RESULTS[e0ef4bfc15551f9d05baeb3970cd8dafaf02db65]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ 2 a {b}^{3}} \cr \cr \displaystyle{ 3 {a}^{2} {b}^{2}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 750} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 675} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ 210937500 {a}^{6} {b}^{27}} \cr \cr \displaystyle{ 284765625 {a}^{8} {b}^{24}}\end{bmatrix}}\end{pmatrix}
\end{equation}

**** Exercise 9.2: Computing Derivatives
     :PROPERTIES:
     :header-args+: :tangle ch9/ex9-2.scm :comments org
     :END:

#+begin_src scheme :exports none
(load "ch1/utils.scm")
#+end_src

A further exercise is to try defining the functions so that they use explicit
tuples, so you can compose them:

#+begin_src scheme
(define (F* v)
  (let ((x (ref v 0))
        (y (ref v 1)))
    (* (square x) (cube y))))

(define (G* v)
  (let ((x (ref v 0))
        (y (ref v 1)))
    (up (F* v) y)))

(define H* (compose F* G*))
#+end_src

#+RESULTS:
: #| F* |#
:
: #| G* |#
:
: #| H* |#

to be really pro, I'd make a function that takes these as arguments and prints a
nice formatted exercise output. Let's do the final exercise, for fun:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 (up ((D F*) (up 'a 'b))
     ((D G*) (up 3 5))
     ((D H*) (up (* 3 (square 'a)) (* 5 (cube 'b))))))
#+end_src

#+RESULTS[1e43354828c8ce0ba497bcc6bd9e64c4f4e20419]:
\begin{equation}
\begin{pmatrix} \displaystyle{ \begin{bmatrix} \displaystyle{ 2 a {b}^{3}} \cr \cr \displaystyle{ 3 {a}^{2} {b}^{2}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ \begin{pmatrix} \displaystyle{ 750} \cr \cr \displaystyle{ 0}\end{pmatrix}} \cr \cr \displaystyle{ \begin{pmatrix} \displaystyle{ 675} \cr \cr \displaystyle{ 1}\end{pmatrix}}\end{bmatrix}} \cr \cr \displaystyle{ \begin{bmatrix} \displaystyle{ 210937500 {a}^{6} {b}^{27}} \cr \cr \displaystyle{ 284765625 {a}^{8} {b}^{24}}\end{bmatrix}}\end{pmatrix}
\end{equation}

* Org-Mode Demo
  :PROPERTIES:
  :header-args: :eval no-export
  :END:

This is an example of how we might structure an org-mode file that can export
out to Github flavored Markdown, or to a PDF.

First, let's get some code loaded up and written. Here's a block that converts
polar coordinates to rectangular coordinates.

#+name: p->r
#+begin_src scheme :eval no
(define (p->r local)
  (let* ((polar-tuple (coordinate local))
         (r (ref polar-tuple 0))
         (phi (ref polar-tuple 1))
         (x (* r (cos phi)))
         (y (* r (sin phi))))
    (up x y)))
#+end_src

This is some good stuff.

#+begin_src scheme :results output :noweb yes :comments both
(load "ch1/utils.scm")

<<p->r>>

<<spherical->rect>>
#+end_src

And another, that gets us from spherical to rectangular.

#+name: spherical->rect
#+begin_src scheme :eval no
(define (spherical->rect local)
  (let* ((spherical-tuple (coordinate local))
         (r (ref spherical-tuple 0))
         (theta (ref spherical-tuple 1))
         (phi (ref spherical-tuple 2)))
    (up (* r (sin theta) (cos phi))
        (* r (sin theta) (sin phi))
        (* r (cos theta)))))
#+end_src

#+RESULTS[f4f039075baf66ba4fe071844815bfcffe281eaa]:
: ;Loading "ch1/utils.scm"... done
: #| "" |#

This block will generate a LaTeX version of the code I've supplied:

#+begin_src scheme :results value raw :exports both :cache yes
(->tex-equation
 ((+ (literal-function 'c)
     (D (literal-function 'z)))
  't)
 "eq:masterpiece")
#+end_src

#+RESULTS[b383d2f5d6c252ac04a5f44aaeaec678132b8449]:
\begin{equation}
c\left( t \right) + Dz\left( t \right)
\label{eq:masterpiece}
\end{equation}

You can even reference these with equation numbers, like Equation \eqref{eq:masterpiece} above.

#+begin_src scheme :results value :exports both :cache yes
(up 1 2 't)
#+end_src

#+RESULTS:
: #|
: (up 1 2 t)
: |#

*** Equations

Here's (a test) of $a = bc$ and more $$ \alpha_t $$ equations:

And again this is a thing:

\[
e^{i\pi} = -1
\]

\[
\int_0^\infty e^{-x^2} dx = \frac{\sqrt{\pi}}{2}
\]


$\vec{x} \dot (\vec{x} \times \vec{v}) = \vec{v} \dot (\vec{x} \times \vec{v}) =
0$

$\vec{x} \cdot (\vec{x} \times \vec{v}) = \vec{v} \dot (\vec{x} \times \vec{b}) =
0$
